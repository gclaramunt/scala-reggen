<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Scala-reggen : Generic programming experiment in Scala">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Scala-reggen</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/gclaramunt/scala-reggen">View on GitHub</a>

          <h1 id="project_title">Scala-reggen</h1>
          <h2 id="project_tagline">Generic programming experiment in Scala</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/gclaramunt/scala-reggen/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/gclaramunt/scala-reggen/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="scala-reggen" class="anchor" href="#scala-reggen"><span class="octicon octicon-link"></span></a>scala-reggen</h1>

<p>Generic programming experiment in Scala</p>

<p>A category theory based approach to generic programming, where each datatype is described by a functor polynomial and defining a function used to fold each regular functor class.</p>

<p>In homage to Miles Sabin's awesome <a href="https://github.com/milessabin/shapeless">Shapeless</a> this library should be eventually called "Useless"</p>

<h2>
<a name="sample-code" class="anchor" href="#sample-code"><span class="octicon octicon-link"></span></a>Sample code</h2>

<p>( from <a href="./blob/master/src/main/scala/reggen/SampleGenericCode.scala">SampleGenericCode.scala</a> )  </p>

<pre><code>object SampleGenericCode extends App {

  val ti:TreeInt=NodeI(LeafI(1),LeafI(2))
  val tp:Tree[Int]=Node(Leaf(1),Leaf(2))
  val l=List(1,2,3,4)

  def sum[Z]:Regular[Z]#PF[Int]=&gt;Int = {
    case U() =&gt; 0
    case k:K[Int,Z] =&gt; k.unK
    case i:I[Int] =&gt; i.unI
    case l:L[Regular[Z]#PF[Int],_]  =&gt; sum(l.f)
    case r:R[_,Regular[Z]#PF[Int]]  =&gt; sum(r.g)
    case star:(Regular[Z]#PF[Int]:*:Regular[Z]#PF[Int])  =&gt; sum(star.f)+sum(star.g)
  }

  println("sum of TreeInt = " + fold(ti)(sum))
  println("sum of Tree[Int] = " + fold(tp)(sum))
  println("sum of List[Int] = " + fold(l)(sum))

}
</code></pre>

<h2>
<a name="tldr" class="anchor" href="#tldr"><span class="octicon octicon-link"></span></a>TL;DR</h2>

<p>Since a fold can be interpreted as replacing a type's constructors with functions and any type can be described with an algebra of functors, by defining our functions over the elements of the algebra, we can write programs that are independent of the shape of the datatype. 
Our algebra of functors consists of:
1 (unit), K (constant), I (identity), * (product), + (sum)</p>

<p>e.g.</p>

<p>List[A] ( Nil | Cons (a:A, l:List[A]) ) is represented as 1 + K A * I</p>

<p>Tree[A] (Leaf(a:A) |  Node(l:Tree[A],r:Tree[A])) is represented as K A + I * I</p>

<p>Then a generic fold just takes a function that pattern matches over the components of the functors.</p>

<p>e.g. for the sum:</p>

<pre><code>  sum :: F a -&gt; int
  sum 1 = 0
  sum K a = a
  sum (inl x) = sum x -- left injection (of functor's) +
  sum (inr x) = sum x -- right injection (of functor's) +
  sum (x * y) = sum x + sum y 
</code></pre>

<h2>
<a name="background" class="anchor" href="#background"><span class="octicon octicon-link"></span></a>Background</h2>

<h3>
<a name="a-100-mph-tour-into-category-theory-land" class="anchor" href="#a-100-mph-tour-into-category-theory-land"><span class="octicon octicon-link"></span></a>A 100 mph tour into Category theory land</h3>

<p>This library uses category theory as the basis for its machinery, so to understand how it works, we need some theory.</p>

<p>NOTE: This is a quick and far from rigorous pass, the theory behind this is explained in <a href="http://www.fing.edu.uy/inco/cursos/proggen/Papers/FGP.pdf.gz">Pardo, Alberto - Fundamentals of Generic Programming</a></p>

<p><a href="http://alissapajer.github.io/conferenceslides/craftconf2014/#/">Alissa Pajer</a> does a great introduction to the basic concepts and how they relate to programming</p>

<h3>
<a name="categories" class="anchor" href="#categories"><span class="octicon octicon-link"></span></a>Categories</h3>

<p>A category is a collection of objects and arrows between them with identity and composition:</p>

<p>Obj(Cat): collection of objects.
For each A,B ∈ Obj(Cat), there’s a set C(A,B) of morphisms (arrows) from A to B
f:A→B means f ∈ C(A,B)</p>

<p>(Formally, a category is defined by 3 total functions: source, target, id;  and one partial function: composition)</p>

<p>Composition operation between arrows:
if f:A→B and g:B→C, then g∘f:A→C
Must be associative: f∘(g∘h) = (f∘g)∘h</p>

<p>For each object X, exists an identity arrow IdX:X→X, such as IdB∘f=f∘IdA=f for each f:A→B</p>

<p>In other words, to effectively form a Category, the choosen arrow composition must be associative and it must be unique </p>

<h3>
<a name="functors" class="anchor" href="#functors"><span class="octicon octicon-link"></span></a>Functors</h3>

<p>A functor from cat. C to cat. D is a pair of functions one maps objects of C to D and the other maps arrows of C to D
functor F:C→D, A ∈C⇒FA∈D, f ∈C⇒Ff∈D</p>

<p>A functor must satisfy the following laws:
Ff:FA→FB
F(f∘g)=Ff∘Fg
FidA=idFA</p>

<p>(TO BE DONE:)</p>

<h3>
<a name="initial-algebras" class="anchor" href="#initial-algebras"><span class="octicon octicon-link"></span></a>Initial Algebras</h3>

<p>(how types and functions are a category)
(how type constructors )
(how types can be described as an algebra of functors)</p>

<h3>
<a name="folds" class="anchor" href="#folds"><span class="octicon octicon-link"></span></a>Folds</h3>

<p>(define fold)
  (laws)</p>

<p>(how fold is the unversal operation)</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Scala-reggen maintained by <a href="https://github.com/gclaramunt">gclaramunt</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-1731182-3");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
