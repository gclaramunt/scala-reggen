{"name":"Scala-reggen","tagline":"Generic programming experiment in Scala","body":"scala-reggen\r\n============\r\n\r\nGeneric programming experiment in Scala\r\n\r\nA category theory based approach to generic programming, where each datatype is described by a functor polynomial and defining a function used to fold each regular functor class.\r\n\r\nIn homage to Miles Sabin's awesome [Shapeless](https://github.com/milessabin/shapeless) this library should be eventually called \"Useless\"\r\n\r\nSample code\r\n-----------\r\n( from [SampleGenericCode.scala](./blob/master/src/main/scala/reggen/SampleGenericCode.scala) )  \r\n```\r\nobject SampleGenericCode extends App {\r\n\r\n  val ti:TreeInt=NodeI(LeafI(1),LeafI(2))\r\n  val tp:Tree[Int]=Node(Leaf(1),Leaf(2))\r\n  val l=List(1,2,3,4)\r\n\r\n  def sum[Z]:Regular[Z]#PF[Int]=>Int = {\r\n    case U() => 0\r\n    case k:K[Int,Z] => k.unK\r\n    case i:I[Int] => i.unI\r\n    case l:L[Regular[Z]#PF[Int],_]  => sum(l.f)\r\n    case r:R[_,Regular[Z]#PF[Int]]  => sum(r.g)\r\n    case star:(Regular[Z]#PF[Int]:*:Regular[Z]#PF[Int])  => sum(star.f)+sum(star.g)\r\n  }\r\n  \r\n  println(\"sum of TreeInt = \" + fold(ti)(sum))\r\n  println(\"sum of Tree[Int] = \" + fold(tp)(sum))\r\n  println(\"sum of List[Int] = \" + fold(l)(sum))\r\n\r\n}\r\n```\r\n\r\nTL;DR\r\n-----\r\nSince a fold can be interpreted as replacing a type's constructors with functions and any type can be described with an algebra of functors, by defining our functions over the elements of the algebra, we can write programs that are independent of the shape of the datatype. \r\nOur algebra of functors consists of:\r\n1 (unit), K (constant), I (identity), * (product), + (sum)\r\n \r\ne.g.\r\n\r\nList\\[A\\] ( Nil | Cons (a:A, l:List\\[A\\]) ) is represented as 1 + K A * I\r\n\r\nTree\\[A\\] (Leaf(a:A) |  Node(l:Tree\\[A\\],r:Tree\\[A\\])) is represented as K A + I * I\r\n\r\nThen a generic fold just takes a function that pattern matches over the components of the functors.\r\n\r\ne.g. for the sum:\r\n```\r\n  sum :: F a -> int\r\n  sum 1 = 0\r\n  sum K a = a\r\n  sum (inl x) = sum x -- left injection (of functor's) +\r\n  sum (inr x) = sum x -- right injection (of functor's) +\r\n  sum (x * y) = sum x + sum y \r\n```\r\n\r\nBackground\r\n----------\r\n\r\n### A 100 mph tour into Category theory land\r\n\r\nThis library uses category theory as the basis for its machinery, so to understand how it works, we need some theory.\r\n\r\nNOTE: This is a quick and far from rigorous pass, the theory behind this is explained in [Pardo, Alberto - Fundamentals of Generic Programming](http://www.fing.edu.uy/inco/cursos/proggen/Papers/FGP.pdf.gz)\r\n\r\n[Alissa Pajer](http://alissapajer.github.io/conferenceslides/craftconf2014/#/) does a great introduction to the basic concepts and how they relate to programming\r\n\r\n### Categories\r\nA category is a collection of objects and arrows between them with identity and composition:\r\n\r\nObj(Cat): collection of objects.\r\nFor each A,B ∈ Obj(Cat), there’s a set C(A,B) of morphisms (arrows) from A to B\r\nf:A→B means f ∈ C(A,B)\r\n\r\n(Formally, a category is defined by 3 total functions: source, target, id;  and one partial function: composition)\r\n\r\nComposition operation between arrows:\r\nif f:A→B and g:B→C, then g∘f:A→C\r\nMust be associative: f∘(g∘h) = (f∘g)∘h\r\n\r\nFor each object X, exists an identity arrow IdX:X→X, such as IdB∘f=f∘IdA=f for each f:A→B\r\n\r\nIn other words, to effectively form a Category, the choosen arrow composition must be associative and it must be unique \r\n\r\n### Functors\r\nA functor from cat. C to cat. D is a pair of functions one maps objects of C to D and the other maps arrows of C to D\r\nfunctor F:C→D, A ∈C⇒FA∈D, f ∈C⇒Ff∈D\r\n\r\nA functor must satisfy the following laws:\r\nFf:FA→FB\r\nF(f∘g)=Ff∘Fg\r\nFidA=idFA\r\n\r\n(TO BE DONE:)\r\n\r\n### Initial Algebras\r\n(how types and functions are a category)\r\n(how type constructors )\r\n(how types can be described as an algebra of functors)\r\n\r\n### Folds\r\n\r\n(define fold)\r\n  (laws)\r\n\r\n(how fold is the unversal operation)\r\n","google":"UA-1731182-3","note":"Don't delete this file! It's used internally to help with page regeneration."}